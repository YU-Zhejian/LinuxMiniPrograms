# `code-spec`: How to write readable codes for green hands in a Small Group Projects

This is a how-to documentation for those green hands who have not been taught how to code.

If you've already installed Pandoc (Available from <https://www.pandoc.org/>), you may execute `build.cmd` (Microsoft Windows) or `build.sh` (GNU/Linux) to compile (render) it into HTML. You may also use GNU Make to build multiple targets (`all`, `docx`, `pdf`, `html`) if you know how to use them.



Some of the following texts are adapted from <https://github.com/YU-Zhejian/IBI-ICA-G6>, the first group project I've been into.

Suppose you're working with people\* over a small project with Git.

\*: For those who do not understand the technology, we call them green hands; for those green hands who is unwilling to learn, we call them lusers.

## General Principles

1. 代码千万行，注释第一行；注释不规范，同事两行泪。

	Roads are countless, comment is foremost; with unregulated comments your collegues may end up in tears.
	(This line is originated from the movie *Wondering Earth* and appears in every public project of me.)
	
	Comments and documentations of all forms are important in all codes you wrote in a group. You have to make your colleagues understand at least how to operate the code you write.
	
	For example, when writing a Python function (The function below is from `gzip` module in Python 3.9.1.):
	
	```python
	def open(filename, mode="rb", compresslevel=_COMPRESS_LEVEL_BEST, encoding=None, errors=None, newline=None):
	"""Open a gzip-compressed file in binary or text mode.
	
	The filename argument can be an actual filename (a str or bytes object), or
	an existing file object to read from or write to.
	
	The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or "ab" for
	binary mode, or "rt", "wt", "xt" or "at" for text mode. The default mode is
	"rb", and the default compresslevel is 9.
	
	For binary mode, this function is equivalent to the GzipFile constructor:
	GzipFile(filename, mode, compresslevel). In this case, the encoding, errors
	and newline arguments must not be provided.
	
	For text mode, a GzipFile object is created, and wrapped in an
	io.TextIOWrapper instance with the specified encoding, error handling
	behavior, and line ending(s).
	
	"""
	[...]
	```
	
	You can see there is a string wrapped in triple quotes under the declaration of the function `open`. That is called "docstring" and gives the usage of this function. You should write them in your functions.
	
	For another example, this is the script for enabling git prompt support in Bash/Zsh (Included in the source code of Git, available at <https://github.com/git/git>):
	
	```bash
	# bash/zsh git prompt support
	#
	# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
	# Distributed under the GNU General Public License, version 2.0.
	#
	# This script allows you to see repository status in your prompt.
	#
	# To enable:
	#
	#    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).
	#    2) Add the following line to your .bashrc/.zshrc:
	#        source ~/.git-prompt.sh
	#    3a) Change your PS1 to call __git_ps1 as
	#        command-substitution:
	#        Bash: PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
	#        ZSH:  setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 " (%s)")]\$ '
	#        the optional argument will be used as format string.
	#    3b) Alternatively, for a slightly faster prompt, __git_ps1 can
	#        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh
	#        with two parameters, <pre> and <post>, which are strings
	#        you would put in $PS1 before and after the status string
	#        generated by the git-prompt machinery.  e.g.
	#        Bash: PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\\\$ "'
	#          will show username, at-sign, host, colon, cwd, then
	#          various status string, followed by dollar and SP, as
	#          your prompt.
	#        ZSH:  precmd () { __git_ps1 "%n" ":%~$ " "|%s" }
	#          will show username, pipe, then various status string,
	#          followed by colon, cwd, dollar and SP, as your prompt.
	#        Optionally, you can supply a third argument with a printf
	#        format string to finetune the output of the branch status
	#
	# The repository status will be displayed only if you are currently in a
	# git repository. The %s token is the placeholder for the shown status.
	#
	# The prompt status always includes the current branch name.
	[...]
	
	# __git_ps1 accepts 0 or 1 arguments (i.e., format string)
	# when called from PS1 using command substitution
	# in this mode it prints text to add to bash PS1 prompt (includes branch name)
	#
	# __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)
	# in that case it _sets_ PS1. The arguments are parts of a PS1 string.
	# when two arguments are given, the first is prepended and the second appended
	# to the state string when assigned to PS1.
	# The optional third parameter will be used as printf format string to further
	# customize the output of the git-status string.
	# In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true
	__git_ps1 ()
	{
	[...]
	}
	```
	
	There's no need to see the code. From the comments we can clearly understand what these functions do and how to use this script!

2. For open-source projects, add a license.
	
	For common open-source licenses, you may use GNU General Public License version 3 (Available: <https://www.gnu.org/licenses/gpl-3.0.en.html>) or 3-clause BSD License (Available: <https://directory.fsf.org/wiki/License:BSD-3-Clause>). Licenses like MIT, Apache or Mozilla is also popular.

3. This public projects prefers **MERGING** than **REBASING**. If you follow that guideline, you’ll be fine. If you don’t, people will hate you, and you’ll be scorned by friends and family.
	
	The reason why I write this is because when working with those who can even cause problems when merging, it is wise to kept them out of high-level skills like rebasing, branch-filtering or cherry-picking. Otherwise your repository may boom and you will be blamed for failing to give them a good explanation.

4. **NEVER PREFORM FORCE PUSH**. If you accidentally committed and pushed something wrong, fix it as fast as possible and commit \& push it again.

5. Pull before you push, or you will be **rejected** by Git (the ***software***, not me).

6. Beware of merge conflicts, they bite you!

7. **DO NOT ADD ARCHIVES (e. g. Zip)**, no matter it is an archived file or folder. Use **Markdown/LaTeX** instead of Word or RTF when documenting changes. This allows Git to show what was modified by `git diff` instead of telling us this is a f\*\*ing binary.

8. **THINK TWICE BEFORE YOU COMMIT OR PUSH.**

9. If there are temporary files created by the editor or the IDE, please add them to `.gitignore` to make Git ignore them.

	Other files which should be added may include compiled binaries (e. g. `a.out`, `outcome.exe` if you use C), cache (e. g. The folder `__pycache__` if you use Python), 

10. Use **LF** instead of **CRLF** as the line endings. Use UTF-8 instead of ANSI as default encoding except in Windows Batch files (with suffix `.bat`). Those who use GNU/Linux will appreciate you.

11. **DO ADD A NEWLINE CHARACTER AT THE END OF A FILE.** That is, to left the last line of your script **blank**. The reason of doing this is to make your colleagues read the code more easily under a GNU/Linux Terminal by `cat`.

## The Workflow

Our workflow is simple. Just pull-edit-add-commit-push to the master branch.

### Branching

You're encouraged to branch offline, but please **DO NOT PUSH YOUR BRANCH ONLINE**, unless necessary (e. g. Huge disagreement within our team).

Why? Because if you pushed all your branches,

1. The size of our repository will be huge, which will greatly slow Git down.

2. Who will be responsible for merging them to master? It would be weird for me to merge all those branches and deal with those dick-checking conflicts.

So, why do I recommend our centralized model? Please read the following message:

> 我认为直接在master上开发能够分摊merge的压力（谁push不了谁来merge），历史清晰（一条线）且责任明确（出问题了看谁push的就行了）。

### Fork

I do not recommend you to fork our repository--If you're inside this group, please think of a way to merge your commit without creating a pull request (which will be ignored--I am not available to see your request). If you're not, we'll definitely accuse you of performing academic misconduct.

## Python Specifications

The following specifications are made to make our code more readable:

1. All `python` file should be ended with extension name `py` and under Python version 3 v .
2. Use `# TODO: blablabla` when pending to do something.
3. The way of indenting pseudocode should be the same as those uncommented codes.
4. Use **ONE TAB CHARACTER** instead of  **FOUR WHITE SPACE** as indentation.
5. It is wise to add `#!/usr/bin/env python` at the head of a file. The reason why I add this line is because this enables me to execute the script directly under a GNU/Linux terminal without specifying `python` as my interpreter.

## Recommended Software

Use Typora to read & edit Markdown files.

## FAQ

1. Why don't we use `git-flow` on <https://nvie.com/posts/a-successful-git-branching-model/>? It seems to be a mature model of collaborating.

*Life is short and we should not waste our time like this.*

2. Do you think our current workflow will make this project unstable?

*No point to be stable--We'll check before handing it on.*

# Readme for the Workflow

## Aim

After this "practical", you should know:

1. The basic idea of "Centralized Workflow" (Chacon, S. and Straub, B. 2018).
2. How to handle conflicts when pushing your commits.

## Backgrounds

### The Emergence of Conflict

When you're about to push your commits to the server, conflicts emerge when your commit is not **fast-forward**. The git server will **Reject** your commit and you should **Merge** what is on the server to your workflow.

e. g. `git clone` on local1

```
Remote 1-->2
	   |   |
Local1 1-->2
```

`git commit` on local1

```
Remote 1-->2
	   |   |
Local1 1-->2-->4
# Your commit is fast-forward. You can push and no conflict will emerge.
```

However, if someone else pushed his/her commits before yours, there will be problems. e. g.

```
Remote 1-->2---->3
	   |   |     |
Local1 1-->2-->4 |
				 |
Local2 1-->2---->3
```

Now, what you should do is to pull others' commit and merge them into your workflow.

### Merge

Sometimes, merge can be done by git automatically. However, this mechanism fails when you and Local2 both modified a specific line. Under that circumstance, you should reopen the file, merge the changes by an editor, add and commit.

## Procedure

1. Open the file `trial.py` and add some words to **the second line**. Stage and commit your changes.
2. Push your changes back to GitHub. If your changes are **NOT** rejected, back to step 1.
3. If your changes are rejected, pull the newest changes from GitHub and merge them properly.
4. *(Optional)* After finishing those steps, do it again by command line interface.

## Please Pay Attention

1. **DO NOT PERFORM FORCE PUSH.** That can destroy the entire repository!
2. USE `LF` instead of `CRLF` in line endings.

## The Code

These code should be typed into a GNU/Linux terminal. You do not need to append them to `trial.py`.

````bash
git pull
notepad workflow/trial.py
git add .
git commit -m "YOUR COMMIT MESSAGE"
git push
````

If there are conflicts:

````bash
git pull
# Here you should see an error message.
notepad workflow/trial.py
git add .
git commit -m "YOUR COMMIT MESSAGE"
git push
````

You can use `git status` to check if there are conflicts to be solved.

## Reference

Chacon, S. and Straub, B. (2018) *Pro Git 2.1.87*, APress. doi: 10.1007/978-1-4842-0076-6. Available from <https://git-scm.com/book/en/v2>, last accessed 2021-02-19.
