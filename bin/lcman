#!/usr/bin/env bash
# LCMAN V3EP5
set -ue
DN="$(readlink -f "$(dirname "${0}")")"
. "${DN}"/../etc/path.sh
echo -e "\e[33mYuZJLab LiveChat Manager"
echo -e "Copyright (C) 2019-2020 YU Zhejian\e[0m"
if ! [[ "$("${mymore}" --version 2>&1||true)" =~ .*"util-linux".* ]]; then
    echo -e "\e[31mWARNING: Will use ${mycat} as more.\e[0m"
    mymore="${mycat}"
fi
more="${mymore}"
LVCD="${DN}/../var/livechat.d"
if [ ! -e "${LVCD}"/MESSAGES ]; then
    echo -e "\e[31mERROR: livechat.d/MESSAGES not exist.\e[0m"
    exit 1
fi
OLD_IFS="${IFS}"
IFS=";"
tmpfff="$(mktemp -t lcman.XXXXXX)"
. "${DN}"/../lib/libisopt
STDS=()
sf=()
sm=()
se=()
for opt in "${@}"; do
    if isopt "${opt}"; then
        case "${opt}" in
        "-v" | "--version")
            echo -e "\e[33mVersion 3 Emergency Patch 5, compatiable with LiveChat Version 1 & 2.\e[0m"
            exit 0
            ;;
        "-h" | "--help")
            yldoc lcman
            exit 0
            ;;
        --more\:*)
            more="${opt:7}"
            if [ $("${more}" --help &>/dev/null;echo ${?}) -eq 127 ]; then
                echo -e "\e[31mERROR! Invalid More '${more}'! Will use original '${mymore}' instead.\e[0m"
                more="${mymore}"
            else
                echo -e "\e[33mWill use '${more}' as More.\e[0m"
            fi
            ;;
        -f\:*)
            sf=(${sf[@]} ${opt:3})
            ;;
        -m\:*)
            sm=(${sm[@]} ${opt:3})
            ;;
        --from\:*)
            sf=(${sf[@]} ${opt:7})
            ;;
        --message\:*)
            sm=(${sm[@]} ${opt:10})
            ;;
        -e\:*)
            se=(${se[@]} ${opt:3})
            ;;
        --exclude\:*)
            se=(${se[@]} ${opt:10})
            ;;
        "-s" | "--exclude-system")
            se=(${se[@]} "SYSTEM")
            ;;
        *)
            echo -e "\e[31mERROR: Option '${opt}' invalid.\e[0m"
            exit 1
            ;;
        esac
    else
        STDS=("${STDS[@]}" "${opt}")
    fi
done
echo -e "\e[33mReading Databases...\e[0m"
i=0
while read line; do
    msg_tmp=(${line})
    f[${i}]="${msg_tmp[1]}"
    m[${i}]="${msg_tmp[2]}"
    uf[${i}]=false
    um[${i}]=false
    unset msg_tmp
    i=$(($i + 1))
done <"${LVCD}"/MESSAGES
echo -e "\e[33mFiltering...\e[0m"
if [ ${#sf[@]} -eq 0 ]; then
    for ((n = 0; n <= i; n++)); do
        uf[${n}]=true
    done
else
    for item in "${sf[@]}"; do
        for ((n = 0; n <= i - 1; n++)); do
            if [[ ${f[${n}]} == *${item}* ]]; then
                uf[${n}]=true
            fi
        done
    done
fi
if ! [ ${#se[@]} -eq 0 ]; then
    for item in "${se[@]}"; do
        for ((n = 0; n <= i - 1; n++)); do
            if [[ ${f[${n}]} == *${item}* ]]; then
                uf[${n}]=false
            fi
        done
    done
fi
if [ ${#sm[@]} -eq 0 ]; then
    for ((n = 0; n <= i; n++)); do
        um[${n}]=true
    done
else
    for item in "${sm[@]}"; do
        for ((n = 0; n <= i - 1; n++)); do
            if [[ ${m[${n}]} == *${item}* ]]; then
                um[${n}]=true
            fi
        done
    done
fi
n=0
while read line; do
    if ${uf[${n}]} && ${um[${n}]}; then
        msg_tmp=(${line})
        echo -e "\e[31m[${msg_tmp[0]}]\e[0m \e[36m[${msg_tmp[1]}]\e[0m ${msg_tmp[2]}" >>"${tmpfff}"
    fi
    n=$((n + 1))
done <${LVCD}/MESSAGES
"${mycat}" "${tmpfff}" | "${mysort}" | "${more}"
IFS=${OLD_IFS}
exit 0
