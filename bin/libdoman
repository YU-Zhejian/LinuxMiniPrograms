#!/bin/bash
# LIBDOMAN V4P5
DN=$(dirname ${0})
echo -e "\e[33mYuZJLab LibDO Manager.\e[0m"
echo -e "\e[33mCopyright (C) 2020 YU Zhejian\e[0m"
{ . $DN/../lib/libisopt && . $DN/../lib/libmktbl && . $DN/../lib/libdate; } && { echo -e "\e[33mlibisopt, libmktbl, libdate loaded.\e[0m" >&2; }  || { echo -e "\e[31mFail to load libisopt, libmktbl, libdate.\e[0m"  >&2;exit 1; }
more="more"
cmd=0
for opt in "${@}"; do
    if isopt "${opt}"; then
        case ${opt} in
        "-h" | "--help")
            yldoc libdoman
            exit 0
            ;;
        "-v" | "--version")
            echo -e "\e[33mVersion 4 patch 5, compatiable with libdo Version 1.\e[0m"
            exit 0
            ;;
        -o\:*)
            cmd=${opt:3}
            ;;
        --output\:*)
            cmd=${opt:9}
            ;;
        --more\:*)
            more=${opt:7}
            if [ $("${more}" --help &> /dev/null;echo ${?}) -ne 0 ];then
                echo -e "\e[31mERROR! Invalid More '${more}'! Will use original 'more' instead.\e[0m"
                more="more"
                else
                    echo -e "\e[33mWill use '${more}' as More.\e[0m"
                fi
            ;;
        *)
            echo -e "\e[31mERROR: Option '${opt}' invalid.\e[0m"
            exit 1
            ;;
        esac
        OPT="$OPT ${opt}"
    else
        STDS="${STDS} ${opt}"
    fi
done
STDI=(${STDS})
if [ ${#STDI[@]} -gt 1 ]; then
    echo -e "\e[33m More than one filename was received. Will disable -o option.\e[0m"
    cmd=0
fi
ln=0
if [ ${cmd} -eq 0 ]; then
    for fn in "${STDI[@]}"; do
        if ! [ -f ${fn} ] || [ -z ${fn} ]; then
            echo -e "\e[31mERROR: Filename '${fn}' invalid. Use libdoman -h for help.\e[0m"
            exit 1
        fi
        echo -e "\e[33mLoading ${fn}...0 item proceeded.\e[0m"
        Proj=0
        status=2
        ffn=$(mktemp -t libdo_man.XXXXXX)
        cat ${fn} | grep LIBDO > ${ffn}
        while read line; do
            ln=$((${ln} + 1))
            case ${line} in
            "LIBDO IS GOING TO EXECUTE"*)
                if [ $status -eq 1 ]; then
                    Proj_Time_e[${Proj}]=0
                    Proj_Exit[${Proj}]="-1"
                    Proj_Time[${Proj}]="ERR"
                fi
                Proj=$((${Proj} + 1))
                echo -e "\e[33mLoading ${fn}...${Proj} item proceeded.\e[0m"
                status=1
                Proj_CMD[${Proj}]=${line:26}
                ;;
            "LIBDO STARTED AT"*)
                Proj_Time_s[${Proj}]=$(echo ${line:17} | sed "s/.$//")
                ;;
            "LIBDO STOPPED AT"*)
                Proj_Time_e[${Proj}]=$(echo ${line:17} | sed "s/.$//")
                Proj_Time[${Proj}]=$(timediff "${Proj_Time_s[${Proj}]}" "${Proj_Time_e[${Proj}]}")
                ;;
            "LIBDO EXITED SUCCESSFULLY.")
                status=2
                Proj_Exit[${Proj}]="0"
                ;;
            "LIBDO FAILED, GOT"*)
                status=2
                Proj_Exit[${Proj}]=$(echo ${line:21} | sed "s/.$//")
                ;;
            esac
        done <${ffn}
        if [ $status -eq 1 ]; then
            Proj_Time_e[${Proj}]=0
            Proj_Exit[${Proj}]="-1"
            Proj_Time[${Proj}]="ERR"
        fi
        echo -e "\e[33mFile ${fn} loaded. Making table...\e[0m"
        table=$(mktemp -t libdo_man.XXXXXX)
        echo -e "\#1\n\#S90\n\#1\n\#1" >${table}
        echo "NO.;COMMAND;EXIT;TIME" >>${table}
        for ((i = 1; i <= ${Proj}; i++)); do
            echo "${i};${Proj_CMD[${i}]};${Proj_Exit[${i}]};${Proj_Time[${i}]}" >>${table}
        done
        mktbl ${table}|${more}
        rm ${table}
    done
    unset Proj Proj_CMD Proj_Exit Proj_Time_e Proj_Time_s table
else
    fn=${STDI[0]}
    if ! [ -f ${fn} ] || [ -z ${fn} ]; then
        echo -e "\e[31mERROR: Filename '${fn}' invalid. Use libdoman -h for help.\e[0m"
        exit 1
    fi
    ln_s=0
    ln_e=0
    tmps=$(mktemp -t libdo_man.XXXXXX)
    cat -n ${fn} | grep "LIBDO IS GOING TO EXECUTE" >${tmps}
    while read line; do
        ln=$((${ln} + 1))
        if [ ${ln} -eq ${cmd} ]; then
            ln_s=$(echo $line | cut -f 1 -d " ")
        elif [ ${ln} -gt ${cmd} ]; then
            ln_e=$(($(echo $line | cut -f 1 -d " ") - 1))
            break
        fi
    done <${tmps}
    rm ${tmps}
    if [ ${ln_s} -eq 0 ]; then
        echo -e "\e[31mERROR: ${cmd} too large.\e[0m" >&2
        exit 1
    fi
    if [ ${ln_e} -eq 0 ]; then ln_e=$(($(wc -l ${fn} | cut -f 1 -d " "))); fi
    unset line
    tmpprj=$(mktemp -t libdo_man.XXXXXX)
    cat ${fn} | tail -n $(($(wc -l ${fn} | cut -f 1 -d " ") - ${ln_s} + 1)) | head -n 2 >${tmpprj}
    while read line; do
        case ${line} in
        "LIBDO IS GOING TO EXECUTE"*)
            CMD=${line:26}
            ;;
        "LIBDO STARTED AT"*)
            Time_s=$(echo ${line:17} | sed "s/.$//")
            ;;
        esac
    done <${tmpprj}
    status=1
    cat ${fn} | head -n ${ln_e} | tail -n 2 >${tmpprj}
    while read line; do
        case ${line} in
        "LIBDO STOPPED AT"*)
            Time_e=$(echo ${line:17} | sed "s/.$//")
            Time=$(timediff "$Time_s" "$Time_e")
            ;;
        "LIBDO EXITED SUCCESSFULLY.")
            status=0
            Exit="0"
            ;;
        "LIBDO FAILED, GOT"*)
            status=0
            Exit=$(echo ${line:21} | sed "s/.$//")
            ;;
        *"WILL KILL"*)
            ln_e=$((${ln_e} - 1))
            ;;
        esac
    done <${tmpprj}
    if [ $status -eq 1 ]; then
        Time_e=0
        Exit="-1"
        Time="ERR"
    fi
    echo -e "\e[33mJOB_CMD      \e[36m: ${CMD}\e[0m" >&2
    echo -e "\e[33mELAPSED_TIME \e[36m: ${Time_s} to ${Time_e}, Total ${Time}\e[0m" >&2
    echo -e "\e[33mEXIT_STATUS  \e[36m: ${Exit}\e[0m" >&2
    echo -e "\e[33m________________JOB_________OUTPUT________________\e[0m" >&2
    tls=$((${ln_s} + 2))
    if [ ${ln_e} -le $tls ]; then
        echo -e "\e[33mNO_OUTPUT\e[0m"
    elif [ ${Exit} -eq -1 ]; then
        cat ${fn} | head -n ${ln_e} | tail -n $((${ln_s} - ${ln_e} + 2)) | ${more}
    else
        cat ${fn} | head -n $((${ln_e} - 2)) | tail -n $((${ln_s} - ${ln_e} + 4)) | ${more}
    fi
    echo -e "\e[33m________________OUTPUT____FINISHED________________\e[0m" >&2
    rm ${tmpprj}
fi
echo -e "\e[33mFinished.\e[0m" >&2
exit 0
